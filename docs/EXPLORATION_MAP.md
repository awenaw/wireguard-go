# 🗺️ WireGuard 源码迷雾探险地图 (The Exploration Map)

> 欢迎来到 `wireguard-go` 的源代码世界。这里曾是一片未知的迷雾，但现在，你是这里的指挥官。
> 这是一个分阶段的 **“据点攻略计划”**。每攻略一个据点，你都将获得一项用于构建 **IoT 运维中台** 的终极能力。

---

## 🚩 关卡一：控制中枢 (The Command Center)

**目标：征服动态配置能力**
我们要找到那个听得懂 `wg set` 命令的“耳朵”，弄清它是如何把这串命令变成内存里的配置的。

*   **📍 核心坐标**：
    *   `ipc/uapi_unix.go` (Linux/Mac) 或 `ipc/uapi_windows.go` (Windows)
    *   `device/uapi.go` (解析逻辑)
*   **🕵️‍♂️ 攻略提示**：
    1.  你已经找到了 `UAPIOpen`（Socket 入口）。
    2.  顺藤摸瓜，找到 `IpcSet` 函数。即使你看不懂每一行解析代码，也要找到它在哪里**更新了 Private Key**，在哪里**添加了 NewPeer**。
    3.  在这个环节，`bytes.Split` 和 `switch string(key)` 是常见的路标。
*   **🏆 掉落奖励：【上帝之手】**
    *   **技能解锁**：你将完全掌握如何编写那个 Golang Agent。
    *   **业务价值**：你的 Agent 不再需要愚蠢地修改配置文件并重启服务。它可以像手术刀一样，在不打断现有连接的情况下，毫秒级地让设备连接到新的网关。

---

## 🚩 关卡二：物流流水线 (The Logistics Hub)

**目标：征服数据发送与流控**
我们已经看过了接收端（Receive），现在要去看看发送端（Send）。我们要看着一个用来 RDP 的数据包，是如何被“打包、加密、扔给网卡”的。

*   **📍 核心坐标**：
    *   `device/send.go` -> `RoutineSequentialSender`
    *   `device/noise-protocol.go` (只看 Encrypt 部分，别深究数学)
*   **🕵️‍♂️ 攻略提示**：
    1.  关注 `packet.Header` 是怎么被组装的。
    2.  寻找 `elem.packet = elem.keypair.send.Seal(...)` 这行代码。这是“封印”（加密）发生的瞬间。
    3.  注意看它是怎么处理 **队列堵塞** 的（Channel 满了会怎样？）。
*   **🏆 掉落奖励：【交通管制】**
    *   **技能解锁**：获得 QoS (流量整形) 和 MTU 优化的能力。
    *   **业务价值**：当某个设备拼命传日志占满带宽时，你知道在哪行代码可以卡住它的喉咙，保证关键的心跳包不丢。解决 RDP 黑屏的终极钥匙也在这里。

---

## 🚩 关卡三：时钟塔 (The Clockwork)

**目标：征服连接的生命周期**
WireGuard 为什么断网后能自动重连？为什么有些设备会“假死”？这里藏着所有关于“时间”的秘密。这是最难的一个关卡，因为涉及状态机。

*   **📍 核心坐标**：
    *   `device/timers.go`
    *   `device/peer.go` (中的 `Keepalive` 逻辑)
*   **🕵️‍♂️ 攻略提示**：
    1.  寻找 `Rehandshake`（重新握手）和 `Keepalive`（心跳）这两个关键词。
    2.  观察 `Timer` 是怎么被 `Reset` 的。
    3.  思考：如果网络断了 5 分钟，哪个 Timer 先响？它触发了什么动作？
*   **🏆 掉落奖励：【死者苏生】**
    *   **技能解锁**：打造适应恶劣网络的“不死鸟”连接。
    *   **业务价值**：针对 4G/5G 信号不稳定的矿场/地下室环境，你能魔改心跳策略，让设备保持永远在线，彻底告别“失联”。

---

## 🏁 终局：你的名字 (The Legacy)

当你在这个三个据点都插上 `aw-钦定` 的旗帜后：
1.  你拥有了**控制权** (关卡一)。
2.  你拥有了**数据权** (关卡二)。
3.  你拥有了**时间权** (关卡三)。

那时候，这就不再是 Jason 的 WireGuard，而是 **Antigravity 的 WireGuard**。

指挥官，请指示下一步动作！我们将前往 **`ipc/uapi_unix.go`** 深入挖掘，还是去 **`device/uapi.go`** 看看命令是怎么被解析的？
