<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WireGuard AllowedIPs Radix Trie å¯è§†åŒ–</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0e1a;
  color: #e0e6f0;
  font-family: 'Inter', sans-serif;
  min-height: 100vh;
  overflow-x: hidden;
}

/* Header */
.header {
  padding: 28px 40px 20px;
  background: linear-gradient(180deg, rgba(15,20,40,0.95) 0%, rgba(10,14,26,0) 100%);
  position: relative;
  z-index: 10;
}
.header h1 {
  font-size: 22px;
  font-weight: 700;
  background: linear-gradient(135deg, #60a5fa, #a78bfa, #f472b6);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: -0.5px;
}
.header p {
  font-size: 13px;
  color: #64748b;
  margin-top: 4px;
}

/* Controls */
.controls {
  display: flex;
  gap: 12px;
  padding: 0 40px 20px;
  flex-wrap: wrap;
  align-items: flex-end;
}
.input-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.input-group label {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: #64748b;
}
.input-group input, .input-group select {
  background: rgba(30, 41, 59, 0.8);
  border: 1px solid rgba(100, 116, 139, 0.3);
  border-radius: 8px;
  padding: 10px 14px;
  color: #e0e6f0;
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  outline: none;
  transition: all 0.2s;
  min-width: 200px;
}
.input-group input:focus, .input-group select:focus {
  border-color: #60a5fa;
  box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.15);
}
.input-group select {
  cursor: pointer;
  min-width: 120px;
}

.btn {
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  font-family: 'Inter', sans-serif;
}
.btn-primary {
  background: linear-gradient(135deg, #3b82f6, #6366f1);
  color: white;
  box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
}
.btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
}
.btn-secondary {
  background: rgba(51, 65, 85, 0.6);
  color: #94a3b8;
  border: 1px solid rgba(100, 116, 139, 0.3);
}
.btn-secondary:hover {
  background: rgba(51, 65, 85, 0.9);
  color: #e0e6f0;
}
.btn-lookup {
  background: linear-gradient(135deg, #10b981, #059669);
  color: white;
  box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
}
.btn-lookup:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
}
.btn-presets {
  background: linear-gradient(135deg, #f59e0b, #d97706);
  color: white;
  box-shadow: 0 2px 10px rgba(245, 158, 11, 0.3);
}
.btn-presets:hover {
  transform: translateY(-1px);
}
.btn-random {
  background: linear-gradient(135deg, #ec4899, #be185d);
  color: white;
  box-shadow: 0 2px 10px rgba(236, 72, 153, 0.3);
}
.btn-random:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(236, 72, 153, 0.4);
}

/* Main Layout */
.main {
  display: flex;
  height: calc(100vh - 160px);
  padding: 0 20px 20px;
  gap: 16px;
}

/* Canvas Container */
.canvas-container {
  flex: 1;
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(100, 116, 139, 0.15);
  border-radius: 12px;
  position: relative;
  overflow: hidden;
}
.canvas-container canvas {
  display: block;
  width: 100%;
  height: 100%;
}
.canvas-hint {
  position: absolute;
  bottom: 12px;
  left: 12px;
  font-size: 11px;
  color: #475569;
  pointer-events: none;
}

/* Side Panel */
.side-panel {
  width: 320px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow-y: auto;
}
.panel-card {
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(100, 116, 139, 0.15);
  border-radius: 12px;
  padding: 16px;
}
.panel-card h3 {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: #64748b;
  margin-bottom: 10px;
}
.log-list {
  max-height: 200px;
  overflow-y: auto;
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  line-height: 1.8;
}
.log-list::-webkit-scrollbar { width: 4px; }
.log-list::-webkit-scrollbar-track { background: transparent; }
.log-list::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }

.log-item { display: flex; align-items: center; gap: 8px; padding: 2px 0; }
.log-dot {
  width: 6px; height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}
.log-dot.insert { background: #60a5fa; }
.log-dot.lookup { background: #34d399; }
.log-dot.glue   { background: #fbbf24; }
.log-dot.exact  { background: #a78bfa; }

/* Tooltip */
.tooltip {
  position: absolute;
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(100, 116, 139, 0.3);
  border-radius: 8px;
  padding: 10px 14px;
  font-size: 12px;
  font-family: 'JetBrains Mono', monospace;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  z-index: 100;
  max-width: 280px;
  line-height: 1.6;
  box-shadow: 0 8px 30px rgba(0,0,0,0.4);
}
.tooltip.visible { opacity: 1; }

/* Legend */
.legend {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: #94a3b8;
}
.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 3px;
}

/* Stats */
.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.stat-item {
  background: rgba(30, 41, 59, 0.5);
  border-radius: 8px;
  padding: 10px;
  text-align: center;
}
.stat-value {
  font-size: 20px;
  font-weight: 700;
  font-family: 'JetBrains Mono', monospace;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.stat-label {
  font-size: 10px;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 2px;
}

/* Lookup result */
.lookup-result {
  padding: 10px 14px;
  border-radius: 8px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  display: none;
  margin-top: 8px;
  animation: fadeIn 0.3s;
}
.lookup-result.found {
  display: block;
  background: rgba(16, 185, 129, 0.1);
  border: 1px solid rgba(16, 185, 129, 0.3);
  color: #34d399;
}
.lookup-result.notfound {
  display: block;
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.3);
  color: #f87171;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>
</head>
<body>

<div class="header">
  <h1>ğŸŒ¿ WireGuard Radix Trie å¯è§†åŒ–</h1>
  <p>äº¤äº’å¼ AllowedIPs è·¯ç”±è¡¨æ¼”ç¤º â€” è¾“å…¥ CIDR ç½‘æ®µï¼Œè§‚å¯Ÿ Trie æ ‘çš„åŠ¨æ€æ„å»ºè¿‡ç¨‹</p>
</div>

<div class="controls">
  <div class="input-group">
    <label>CIDR ç½‘æ®µ</label>
    <input type="text" id="cidrInput" placeholder="ä¾‹å¦‚: 10.0.0.0/24" value="10.0.0.0/16">
  </div>
  <div class="input-group">
    <label>Peer</label>
    <select id="peerSelect">
      <option value="Peer-A">Peer-A</option>
      <option value="Peer-B">Peer-B</option>
      <option value="Peer-C">Peer-C</option>
      <option value="Peer-D">Peer-D</option>
    </select>
  </div>
  <button class="btn btn-primary" onclick="handleInsert()">æ’å…¥ (Insert)</button>
  <button class="btn btn-random" onclick="generateRandomCIDR()">ğŸ² éšæœº</button>

  <div class="input-group">
    <label>æŸ¥æ‰¾ IP</label>
    <input type="text" id="lookupInput" placeholder="ä¾‹å¦‚: 10.0.1.5">
  </div>
  <button class="btn btn-lookup" onclick="handleLookup()">æŸ¥æ‰¾ (Lookup)</button>
  <button class="btn btn-presets" onclick="loadPreset()">åŠ è½½ç¤ºä¾‹</button>
  <button class="btn btn-secondary" onclick="handleReset()">é‡ç½®</button>
</div>

<div class="main">
  <div class="canvas-container">
    <canvas id="trieCanvas"></canvas>
    <div class="tooltip" id="tooltip"></div>
    <div class="canvas-hint">ğŸ–±ï¸ é¼ æ ‡æ‚¬åœèŠ‚ç‚¹æŸ¥çœ‹è¯¦æƒ… Â· æ»šè½®ç¼©æ”¾ Â· æ‹–æ‹½å¹³ç§»</div>
  </div>

  <div class="side-panel">
    <div class="panel-card">
      <h3>ğŸ“Š ç»Ÿè®¡</h3>
      <div class="stats">
        <div class="stat-item">
          <div class="stat-value" id="statNodes">0</div>
          <div class="stat-label">èŠ‚ç‚¹æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="statPeers">0</div>
          <div class="stat-label">Peer èŠ‚ç‚¹</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="statGlue">0</div>
          <div class="stat-label">ä¸­é—´èŠ‚ç‚¹</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="statDepth">0</div>
          <div class="stat-label">æœ€å¤§æ·±åº¦</div>
        </div>
      </div>
    </div>

    <div class="panel-card">
      <h3>ğŸ¨ å›¾ä¾‹</h3>
      <div class="legend">
        <div class="legend-item"><div class="legend-color" style="background:#3b82f6"></div>Peer-A</div>
        <div class="legend-item"><div class="legend-color" style="background:#8b5cf6"></div>Peer-B</div>
        <div class="legend-item"><div class="legend-color" style="background:#f59e0b"></div>Peer-C</div>
        <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div>Peer-D</div>
        <div class="legend-item"><div class="legend-color" style="background:rgba(100,116,139,0.5); border:1px dashed #64748b"></div>ä¸­é—´èŠ‚ç‚¹</div>
      </div>
    </div>

    <div class="panel-card" id="lookupResultCard" style="display:none">
      <h3>ğŸ” æŸ¥æ‰¾ç»“æœ</h3>
      <div class="lookup-result" id="lookupResult"></div>
    </div>

    <div class="panel-card">
      <h3>ğŸ“‹ æ“ä½œæ—¥å¿—</h3>
      <div class="log-list" id="logList"></div>
    </div>
  </div>
</div>

<script>
// ============================================================
// Radix Trie å®ç° (æ¨¡æ‹Ÿ WireGuard allowedips.go)
// ============================================================

const PEER_COLORS = {
  'Peer-A': '#3b82f6',
  'Peer-B': '#8b5cf6',
  'Peer-C': '#f59e0b',
  'Peer-D': '#ef4444',
};

class TrieNode {
  constructor(bits, cidr, peer) {
    this.bits = bits;          // Uint8Array (IP åœ°å€çš„å­—èŠ‚)
    this.cidr = cidr;          // æ©ç é•¿åº¦
    this.peer = peer || null;  // å½’å±çš„ Peer (null è¡¨ç¤ºä¸­é—´èŠ‚ç‚¹)
    this.child = [null, null]; // å·¦å³å­èŠ‚ç‚¹
    this.bitAtByte = Math.floor(cidr / 8);
    this.bitAtShift = 7 - (cidr % 8);

    // å¯è§†åŒ–å±æ€§
    this.x = 0; this.y = 0;
    this.targetX = 0; this.targetY = 0;
    this.highlight = 0; // é«˜äº®åŠ¨ç”»è®¡æ•°å™¨
  }

  choose(ip) {
    if (this.bitAtByte >= ip.length) return 0;
    return (ip[this.bitAtByte] >> this.bitAtShift) & 1;
  }

  maskSelf() {
    const totalBits = this.bits.length * 8;
    for (let i = 0; i < this.bits.length; i++) {
      const bitsInByte = Math.min(8, Math.max(0, this.cidr - i * 8));
      if (bitsInByte >= 8) continue;
      if (bitsInByte <= 0) { this.bits[i] = 0; continue; }
      this.bits[i] &= (0xff << (8 - bitsInByte)) & 0xff;
    }
  }

  getLabel() {
    const parts = [];
    for (let i = 0; i < this.bits.length; i++) parts.push(this.bits[i]);
    return parts.join('.') + '/' + this.cidr;
  }

  getBinaryStr() {
    let s = '';
    for (let i = 0; i < this.bits.length; i++) {
      if (i > 0) s += '.';
      s += this.bits[i].toString(2).padStart(8, '0');
    }
    return s;
  }
}

function commonBits(a, b) {
  let count = 0;
  for (let i = 0; i < a.length; i++) {
    const x = a[i] ^ b[i];
    if (x === 0) { count += 8; continue; }
    // è®¡ç®—å‰å¯¼é›¶
    for (let bit = 7; bit >= 0; bit--) {
      if ((x >> bit) & 1) return count;
      count++;
    }
  }
  return count;
}

class RadixTrie {
  constructor() {
    this.root = null;
    this.logs = [];
  }

  nodePlacement(node, ip, cidr) {
    let parent = null;
    let exact = false;
    while (node !== null && node.cidr <= cidr && commonBits(node.bits, ip) >= node.cidr) {
      parent = node;
      if (parent.cidr === cidr) { exact = true; return { parent, exact }; }
      const bit = node.choose(ip);
      node = node.child[bit];
    }
    return { parent, exact };
  }

  insert(ip, cidr, peer) {
    const ipBytes = new Uint8Array(ip);

    // æƒ…å†µ 0: æ ‘ä¸ºç©º
    if (this.root === null) {
      const node = new TrieNode(new Uint8Array(ipBytes), cidr, peer);
      node.maskSelf();
      node.highlight = 60;
      this.root = node;
      this.log('insert', `æ’å…¥æ ¹èŠ‚ç‚¹ ${node.getLabel()} â†’ ${peer}`);
      return;
    }

    const { parent: node, exact } = this.nodePlacement(this.root, ipBytes, cidr);

    // æƒ…å†µ 1: ç²¾ç¡®åŒ¹é…
    if (exact) {
      const oldPeer = node.peer;
      node.peer = peer;
      node.highlight = 60;
      this.log('exact', `ç²¾ç¡®åŒ¹é… ${node.getLabel()}: ${oldPeer||'æ— '} â†’ ${peer}`);
      return;
    }

    // åˆ›å»ºæ–°èŠ‚ç‚¹
    const newNode = new TrieNode(new Uint8Array(ipBytes), cidr, peer);
    newNode.maskSelf();
    newNode.highlight = 60;

    let down;
    if (node === null) {
      down = this.root;
    } else {
      const bit = node.choose(ipBytes);
      down = node.child[bit];
      // æƒ…å†µ 2: ç®€å•è¿½åŠ 
      if (down === null) {
        node.child[bit] = newNode;
        this.log('insert', `å¶å­æ’å…¥ ${newNode.getLabel()} â†’ ${peer} (æŒ‚åœ¨ ${node.getLabel()} çš„ ${bit===0?'å·¦':'å³'} è¾¹)`);
        return;
      }
    }

    // è®¡ç®—å…¬å…±å‰ç¼€
    let common = commonBits(down.bits, ipBytes);
    if (common < cidr) cidr = common;

    // æƒ…å†µ 3: æ–°èŠ‚ç‚¹æ˜¯ down çš„çˆ¶èŠ‚ç‚¹
    if (newNode.cidr === cidr) {
      const bit = newNode.choose(down.bits);
      newNode.child[bit] = down;
      if (node === null) {
        this.root = newNode;
      } else {
        const pBit = node.choose(newNode.bits);
        node.child[pBit] = newNode;
      }
      this.log('insert', `${newNode.getLabel()} æˆä¸º ${down.getLabel()} çš„çˆ¶èŠ‚ç‚¹`);
      return;
    }

    // æƒ…å†µ 4: åˆ†è£‚ (åˆ›å»ºä¸­é—´èŠ‚ç‚¹)
    const glue = new TrieNode(new Uint8Array(ipBytes), cidr, null);
    glue.maskSelf();
    glue.highlight = 60;

    let bit = glue.choose(down.bits);
    glue.child[bit] = down;
    bit = glue.choose(newNode.bits);
    glue.child[bit] = newNode;

    if (node === null) {
      this.root = glue;
    } else {
      const pBit = node.choose(glue.bits);
      node.child[pBit] = glue;
    }
    this.log('glue', `åˆ†è£‚ï¼åˆ›å»ºä¸­é—´èŠ‚ç‚¹ ${glue.getLabel()} è¿æ¥ ${down.getLabel()} å’Œ ${newNode.getLabel()}`);
  }

  lookup(ip) {
    const ipBytes = parseIP(ip);
    if (!ipBytes) return null;
    let node = this.root;
    let found = null;
    const path = [];
    while (node !== null && commonBits(node.bits, ipBytes) >= node.cidr) {
      path.push(node);
      if (node.peer !== null) {
        found = { peer: node.peer, prefix: node.getLabel() };
      }
      if (node.bitAtByte >= ipBytes.length) break;
      const bit = node.choose(ipBytes);
      node = node.child[bit];
    }
    // é«˜äº®æŸ¥æ‰¾è·¯å¾„
    path.forEach(n => { n.highlight = 60; });
    return found;
  }

  log(type, msg) {
    this.logs.unshift({ type, msg, time: Date.now() });
    if (this.logs.length > 50) this.logs.pop();
  }

  getStats() {
    let total = 0, peers = 0, glue = 0, maxDepth = 0;
    const walk = (node, depth) => {
      if (!node) return;
      total++;
      if (node.peer) peers++; else glue++;
      maxDepth = Math.max(maxDepth, depth);
      walk(node.child[0], depth + 1);
      walk(node.child[1], depth + 1);
    };
    walk(this.root, 0);
    return { total, peers, glue, maxDepth };
  }
}

// ============================================================
// è¾…åŠ©å‡½æ•°
// ============================================================

function parseIP(str) {
  const parts = str.trim().split('.');
  if (parts.length !== 4) return null;
  const bytes = new Uint8Array(4);
  for (let i = 0; i < 4; i++) {
    const v = parseInt(parts[i], 10);
    if (isNaN(v) || v < 0 || v > 255) return null;
    bytes[i] = v;
  }
  return bytes;
}

function parseCIDR(str) {
  const [ipStr, cidrStr] = str.trim().split('/');
  const ip = parseIP(ipStr);
  if (!ip) return null;
  const cidr = parseInt(cidrStr, 10);
  if (isNaN(cidr) || cidr < 0 || cidr > 32) return null;
  return { ip, cidr };
}

function generateRandomCIDR() {
  // å¸¸è§çš„ç§æœ‰ç½‘æ®µå‰ç¼€ï¼Œè®©ç”Ÿæˆçš„ IP æ›´è´´è¿‘çœŸå®åœºæ™¯
  const templates = [
    { prefix: [10], remaining: 3, minCidr: 8 },
    { prefix: [172, 16], remaining: 2, minCidr: 12 },
    { prefix: [192, 168], remaining: 2, minCidr: 16 },
  ];
  const t = templates[Math.floor(Math.random() * templates.length)];
  const octets = [...t.prefix];
  for (let i = 0; i < t.remaining; i++) {
    octets.push(Math.floor(Math.random() * 256));
  }
  // æ©ç èŒƒå›´ï¼šå¯¹åº”ç½‘æ®µçš„æœ€å°æ©ç  ~ 32
  const cidr = t.minCidr + Math.floor(Math.random() * (33 - t.minCidr));
  // æŒ‰æ©ç æ¸…é™¤ä¸»æœºä½
  const ipBytes = new Uint8Array(octets);
  for (let i = 0; i < 4; i++) {
    const bitsInByte = Math.min(8, Math.max(0, cidr - i * 8));
    if (bitsInByte >= 8) continue;
    if (bitsInByte <= 0) { ipBytes[i] = 0; continue; }
    ipBytes[i] &= (0xff << (8 - bitsInByte)) & 0xff;
  }
  const cidrStr = ipBytes.join('.') + '/' + cidr;
  document.getElementById('cidrInput').value = cidrStr;
  // éšæœºé€‰æ‹© Peer
  const peers = ['Peer-A', 'Peer-B', 'Peer-C', 'Peer-D'];
  const peer = peers[Math.floor(Math.random() * peers.length)];
  document.getElementById('peerSelect').value = peer;
}

// ============================================================
// Canvas æ¸²æŸ“
// ============================================================

const canvas = document.getElementById('trieCanvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

let trie = new RadixTrie();
let panX = 0, panY = 0, zoom = 1;
let dragging = false, dragStartX = 0, dragStartY = 0;
let hoveredNode = null;
let animFrame = 0;

function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * devicePixelRatio;
  canvas.height = rect.height * devicePixelRatio;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// å¸ƒå±€ç®—æ³•ï¼šè®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„ x, y åæ ‡
function layoutTree() {
  if (!trie.root) return;
  const nodeW = 140;
  const levelH = 80;
  let xCounter = 0;

  // ç¬¬ä¸€è¶Ÿï¼šåˆ†é… x åæ ‡ (ä¸­åºéå†)
  function assignX(node) {
    if (!node) return;
    assignX(node.child[0]);
    node.targetX = xCounter * nodeW;
    xCounter++;
    assignX(node.child[1]);
  }

  // çˆ¶èŠ‚ç‚¹å±…ä¸­
  function centerParent(node) {
    if (!node) return;
    centerParent(node.child[0]);
    centerParent(node.child[1]);
    if (node.child[0] && node.child[1]) {
      node.targetX = (node.child[0].targetX + node.child[1].targetX) / 2;
    } else if (node.child[0]) {
      node.targetX = node.child[0].targetX;
    } else if (node.child[1]) {
      node.targetX = node.child[1].targetX;
    }
  }

  function assignY(node, depth) {
    if (!node) return;
    node.targetY = depth * levelH;
    assignY(node.child[0], depth + 1);
    assignY(node.child[1], depth + 1);
  }

  xCounter = 0;
  assignX(trie.root);
  centerParent(trie.root);
  assignY(trie.root, 0);

  // ä¸­å¿ƒåç§»
  const bounds = getTreeBounds(trie.root);
  const centerOffsetX = -(bounds.minX + bounds.maxX) / 2;
  function offsetAll(node) {
    if (!node) return;
    node.targetX += centerOffsetX;
    offsetAll(node.child[0]);
    offsetAll(node.child[1]);
  }
  offsetAll(trie.root);
}

function getTreeBounds(node) {
  if (!node) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
  let minX = node.targetX, maxX = node.targetX;
  let minY = node.targetY, maxY = node.targetY;
  [0, 1].forEach(i => {
    if (node.child[i]) {
      const b = getTreeBounds(node.child[i]);
      minX = Math.min(minX, b.minX);
      maxX = Math.max(maxX, b.maxX);
      minY = Math.min(minY, b.minY);
      maxY = Math.max(maxY, b.maxY);
    }
  });
  return { minX, maxX, minY, maxY };
}

// åŠ¨ç”»æ’å€¼
function lerpNodes(node) {
  if (!node) return;
  node.x += (node.targetX - node.x) * 0.12;
  node.y += (node.targetY - node.y) * 0.12;
  if (node.highlight > 0) node.highlight -= 1;
  lerpNodes(node.child[0]);
  lerpNodes(node.child[1]);
}

function drawTree() {
  const dpr = devicePixelRatio;
  ctx.save();
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const w = canvas.width / dpr;
  const h = canvas.height / dpr;

  // æ¸…ç©ºç”»å¸ƒ
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, w, h);

  // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
  ctx.strokeStyle = 'rgba(30,41,59,0.4)';
  ctx.lineWidth = 0.5;
  const gridSize = 40 * zoom;
  const offsetGX = (w / 2 + panX * zoom) % gridSize;
  const offsetGY = (panY * zoom) % gridSize;
  for (let gx = offsetGX; gx < w; gx += gridSize) {
    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, h); ctx.stroke();
  }
  for (let gy = offsetGY; gy < h; gy += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
  }

  if (!trie.root) {
    ctx.fillStyle = '#334155';
    ctx.font = '16px Inter';
    ctx.textAlign = 'center';
    ctx.fillText('æ ‘ä¸ºç©º â€” è¯·è¾“å…¥ CIDR ç½‘æ®µå¹¶ç‚¹å‡»"æ’å…¥"', w / 2, h / 2);
    ctx.restore();
    return;
  }

  // åº”ç”¨å˜æ¢
  ctx.translate(w / 2 + panX * zoom, 60 + panY * zoom);
  ctx.scale(zoom, zoom);

  hoveredNode = null;
  drawNode(trie.root);

  ctx.restore();
}

function drawNode(node) {
  if (!node) return;

  // ç»˜åˆ¶è¿çº¿
  [0, 1].forEach(i => {
    const child = node.child[i];
    if (!child) return;
    ctx.beginPath();
    ctx.moveTo(node.x, node.y + 16);
    // è´å¡å°”æ›²çº¿
    const midY = (node.y + child.y) / 2 + 10;
    ctx.bezierCurveTo(node.x, midY, child.x, midY, child.x, child.y - 16);
    ctx.strokeStyle = node.highlight > 0 && child.highlight > 0
      ? 'rgba(96, 165, 250, 0.7)'
      : 'rgba(71, 85, 105, 0.5)';
    ctx.lineWidth = node.highlight > 0 && child.highlight > 0 ? 2.5 : 1.2;
    ctx.stroke();

    // ç»˜åˆ¶åˆ†æ”¯æ ‡ç­¾ (0 / 1)
    const labelX = (node.x + child.x) / 2 + (i === 0 ? -12 : 12);
    const labelY = (node.y + child.y) / 2;
    ctx.fillStyle = '#475569';
    ctx.font = '10px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText(i.toString(), labelX, labelY);
  });

  // ç»˜åˆ¶èŠ‚ç‚¹
  const isPeer = node.peer !== null;
  const nodeW = isPeer ? 120 : 90;
  const nodeH = isPeer ? 34 : 26;
  const rx = node.x - nodeW / 2;
  const ry = node.y - nodeH / 2;

  // æ£€æµ‹é¼ æ ‡æ‚¬åœ
  const mouseWorld = screenToWorld(mouseScreenX, mouseScreenY);
  const isHovered = mouseWorld &&
    mouseWorld.x >= rx && mouseWorld.x <= rx + nodeW &&
    mouseWorld.y >= ry && mouseWorld.y <= ry + nodeH;
  if (isHovered) hoveredNode = node;

  // é«˜äº®å…‰æ™•
  if (node.highlight > 0) {
    const glowAlpha = node.highlight / 60 * 0.4;
    const color = isPeer ? (PEER_COLORS[node.peer] || '#60a5fa') : '#fbbf24';
    ctx.shadowColor = color;
    ctx.shadowBlur = 20 * (node.highlight / 60);
  }

  // ç»˜åˆ¶åœ†è§’çŸ©å½¢
  ctx.beginPath();
  const r = 6;
  ctx.moveTo(rx + r, ry);
  ctx.lineTo(rx + nodeW - r, ry);
  ctx.quadraticCurveTo(rx + nodeW, ry, rx + nodeW, ry + r);
  ctx.lineTo(rx + nodeW, ry + nodeH - r);
  ctx.quadraticCurveTo(rx + nodeW, ry + nodeH, rx + nodeW - r, ry + nodeH);
  ctx.lineTo(rx + r, ry + nodeH);
  ctx.quadraticCurveTo(rx, ry + nodeH, rx, ry + nodeH - r);
  ctx.lineTo(rx, ry + r);
  ctx.quadraticCurveTo(rx, ry, rx + r, ry);
  ctx.closePath();

  if (isPeer) {
    const color = PEER_COLORS[node.peer] || '#60a5fa';
    ctx.fillStyle = isHovered ? color : hexToRgba(color, 0.15);
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = isHovered ? 2 : 1.2;
    ctx.stroke();
  } else {
    ctx.fillStyle = isHovered ? 'rgba(100,116,139,0.3)' : 'rgba(30,41,59,0.6)';
    ctx.fill();
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(100,116,139,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
  }

  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  // ç»˜åˆ¶æ–‡å­—
  ctx.font = `${isPeer ? 11 : 10}px JetBrains Mono`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = isPeer ? (isHovered ? '#fff' : '#e0e6f0') : '#94a3b8';
  ctx.fillText(node.getLabel(), node.x, node.y);

  // é€’å½’ç»˜åˆ¶å­èŠ‚ç‚¹
  drawNode(node.child[0]);
  drawNode(node.child[1]);
}

function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

let mouseScreenX = 0, mouseScreenY = 0;

function screenToWorld(sx, sy) {
  const dpr = devicePixelRatio;
  const rect = canvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  const localX = sx - rect.left;
  const localY = sy - rect.top;
  const wx = (localX - w / 2 - panX * zoom) / zoom;
  const wy = (localY - 60 - panY * zoom) / zoom;
  return { x: wx, y: wy };
}

// ============================================================
// äº¤äº’äº‹ä»¶
// ============================================================

canvas.addEventListener('mousemove', (e) => {
  mouseScreenX = e.clientX;
  mouseScreenY = e.clientY;

  if (dragging) {
    panX += (e.clientX - dragStartX) / zoom;
    panY += (e.clientY - dragStartY) / zoom;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
  }

  // æ›´æ–° tooltip
  if (hoveredNode) {
    const n = hoveredNode;
    let html = `<b>${n.getLabel()}</b><br>`;
    html += `äºŒè¿›åˆ¶: ${n.getBinaryStr().substring(0, n.cidr + Math.floor(n.cidr/8))}â€¦<br>`;
    html += `bitAtByte: ${n.bitAtByte}, bitAtShift: ${n.bitAtShift}<br>`;
    html += n.peer ? `<span style="color:${PEER_COLORS[n.peer]||'#fff'}">â— ${n.peer}</span>` : '<span style="color:#94a3b8">â— ä¸­é—´èŠ‚ç‚¹ (Glue)</span>';
    tooltip.innerHTML = html;
    tooltip.style.left = (e.clientX + 15) + 'px';
    tooltip.style.top = (e.clientY + 15) + 'px';
    tooltip.classList.add('visible');
    canvas.style.cursor = 'pointer';
  } else {
    tooltip.classList.remove('visible');
    canvas.style.cursor = dragging ? 'grabbing' : 'grab';
  }
});

canvas.addEventListener('mousedown', (e) => {
  dragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  canvas.style.cursor = 'grabbing';
});

canvas.addEventListener('mouseup', () => {
  dragging = false;
  canvas.style.cursor = 'grab';
});

canvas.addEventListener('mouseleave', () => {
  dragging = false;
  tooltip.classList.remove('visible');
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const factor = e.deltaY > 0 ? 0.9 : 1.1;
  zoom = Math.max(0.2, Math.min(3, zoom * factor));
}, { passive: false });

// é”®ç›˜å¿«æ·é”®
document.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const active = document.activeElement;
    if (active === document.getElementById('cidrInput')) handleInsert();
    else if (active === document.getElementById('lookupInput')) handleLookup();
  }
});

// ============================================================
// ä¸šåŠ¡é€»è¾‘
// ============================================================

function handleInsert() {
  const input = document.getElementById('cidrInput').value;
  const peer = document.getElementById('peerSelect').value;
  const parsed = parseCIDR(input);
  if (!parsed) {
    alert('æ— æ•ˆçš„ CIDR æ ¼å¼ã€‚è¯·è¾“å…¥å¦‚ 10.0.0.0/24 çš„æ ¼å¼ã€‚');
    return;
  }
  trie.insert(parsed.ip, parsed.cidr, peer);
  layoutTree();
  updateUI();
}

function handleLookup() {
  const input = document.getElementById('lookupInput').value;
  const ip = parseIP(input);
  if (!ip) {
    alert('æ— æ•ˆçš„ IP åœ°å€ã€‚è¯·è¾“å…¥å¦‚ 10.0.1.5 çš„æ ¼å¼ã€‚');
    return;
  }

  const result = trie.lookup(input);
  const card = document.getElementById('lookupResultCard');
  const el = document.getElementById('lookupResult');
  card.style.display = 'block';

  if (result) {
    el.className = 'lookup-result found';
    el.innerHTML = `âœ… åŒ¹é…: ${result.prefix}<br>â†’ ${result.peer}`;
    trie.log('lookup', `æŸ¥æ‰¾ ${input} â†’ åŒ¹é… ${result.prefix} (${result.peer})`);
  } else {
    el.className = 'lookup-result notfound';
    el.innerHTML = `âŒ æœªæ‰¾åˆ°åŒ¹é…çš„è·¯ç”±`;
    trie.log('lookup', `æŸ¥æ‰¾ ${input} â†’ æ— åŒ¹é…`);
  }
  updateUI();
}

function handleReset() {
  trie = new RadixTrie();
  panX = 0; panY = 0; zoom = 1;
  document.getElementById('lookupResultCard').style.display = 'none';
  updateUI();
}

function loadPreset() {
  handleReset();
  const presets = [
    ['10.0.0.0/8',       'Peer-A'],
    ['10.0.1.0/24',      'Peer-B'],
    ['10.0.2.0/24',      'Peer-C'],
    ['192.168.1.0/24',   'Peer-D'],
    ['192.168.1.128/25', 'Peer-B'],
    ['10.0.1.5/32',      'Peer-C'],
  ];

  let delay = 0;
  presets.forEach(([cidr, peer]) => {
    setTimeout(() => {
      const parsed = parseCIDR(cidr);
      trie.insert(parsed.ip, parsed.cidr, peer);
      layoutTree();
      updateUI();
    }, delay);
    delay += 400;
  });
}

function updateUI() {
  const stats = trie.getStats();
  document.getElementById('statNodes').textContent = stats.total;
  document.getElementById('statPeers').textContent = stats.peers;
  document.getElementById('statGlue').textContent = stats.glue;
  document.getElementById('statDepth').textContent = stats.maxDepth;

  // æ›´æ–°æ—¥å¿—
  const logEl = document.getElementById('logList');
  logEl.innerHTML = trie.logs.map(l => {
    return `<div class="log-item"><span class="log-dot ${l.type}"></span><span>${l.msg}</span></div>`;
  }).join('');
}

// ============================================================
// ä¸»å¾ªç¯
// ============================================================

function animate() {
  animFrame++;
  if (trie.root) {
    lerpNodes(trie.root);
  }
  drawTree();
  requestAnimationFrame(animate);
}

// åˆå§‹åŒ–
layoutTree();
animate();
</script>

</body>
</html>
